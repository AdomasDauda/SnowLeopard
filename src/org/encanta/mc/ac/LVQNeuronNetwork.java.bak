package org.encanta.mc.ac;

import java.util.AbstractMap;
import java.util.Arrays;
import java.util.HashMap;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Random;
import java.util.Set;

public class LVQNeuronNetwork {
	private Map<String, Double[]> input_layer;
	private Map<String, Double[]> output_layer;
	private Map<Double, Double[]> distances;
	private int input_features;
	private double step_alpha;
	private double step_alpha_del_rate;

	public LVQNeuronNetwork(double step_alpha, double step_alpha_del_rate) {
		this.input_layer = new HashMap<String, Double[]>();
		this.output_layer = new HashMap<String, Double[]>();
		this.distances = new HashMap<Double, Double[]>();
		this.step_alpha = step_alpha;
		this.step_alpha_del_rate = step_alpha_del_rate;
	}

	public void initialize(int rangeMin, int rangeMax) {
		// initialize output layers according to the features
		for (Entry<String, Double[]> entry : this.input_layer.entrySet()) {
			Double[] randOutput = new Double[input_features];
			for (int i = 0; i <= input_features - 1; i++)
				randOutput[i] = randint(rangeMin, rangeMax);
			output_layer.put(entry.getKey(), randOutput);
		}
	}

	public void input(String category, Double[] data) {
		this.input_layer.put(category, data);

		// simulate how many features(dimensions) do the input data have
		Object[] values = this.input_layer.values().toArray();
		input_features = ((Double[]) values[0]).length;
	}

	public Entry<String, Double[]> getWinner(Double[] input) {
		// Winner is the neuron nearest to the input
		this.distances.clear();
		for (Entry<String, Double[]> entry : this.output_layer.entrySet()) {
			double distance = 0;
			Double[] output = entry.getValue();
			for (int i = 0; i <= input.length - 1; i++)
				distance += Math.pow(input[i] - output[i], 2);
			// I don't open root here as it's unnecessary
			// System.out.println(distance);
			distances.put(distance, entry.getValue());
		}
		double winner_distance = getMinKey(distances);
		Double[] winner_features = distances.get(winner_distance);
		// System.out.println("Winner: " + getKey(output_layer,winner_features)
		// + " " + Arrays.asList(winner_features));
		Entry<String, Double[]> winner = new AbstractMap.SimpleEntry<String, Double[]>(
				getKey(output_layer, winner_features), winner_features);
		return winner;
	}

	// 将输出节点朝着当前的节点逼近或远离
	public void move(String input_category, Double[] input, Double[] output) {
		// 会自动查找output所属的类别
	}
	
	public void train() {

	}

	public void print_inputlayers() {
		System.out.println("Input layers: " + this.input_layer.size() + " category(s)");
		for (Entry<String, Double[]> entry : this.input_layer.entrySet()) {
			System.out.println("  " + entry.getKey() + " " + Arrays.asList(entry.getValue()));
		}
	}

	public void print_outputlayers() {
		System.out.println("Output layers: " + this.output_layer.size() + " category(s)");
		for (Entry<String, Double[]> entry : this.output_layer.entrySet()) {
			System.out.println("  " + entry.getKey() + " " + Arrays.asList(entry.getValue()));
		}
	}

	private double randint(int min, int max) {
		// return new Random().nextInt(max - min + 1) + min;
		return new Random().nextDouble();
	}

	public static Double getMinKey(Map<Double, Double[]> map) {
		if (map == null)
			return null;
		Set<Double> set = map.keySet();
		Object[] obj = set.toArray();
		Arrays.sort(obj);
		return (Double) obj[0];
	}

	private static String getKey(Map<String, Double[]> map, Double[] value) {
		String key = "";
		for (Map.Entry<String, Double[]> entry : map.entrySet()) {
			if (value.equals(entry.getValue())) {
				key = entry.getKey();
			}
		}
		return key;
	}

}

class Dataset {
	String category;
	Double[] data;
	
	public Dataset(String category, Double[] data) {
		this.category = category;
		this.data = data;
	}
}
